package book.chap08;

public class ChildSimuation {
	
	public static void main(String[] args) {
		Parent p = new Parent(); //부(선언부) 부(생성부)
		//선언부의 타입이 아닌 생성부의 타입으로 객체가 생성되는 것이다.
		Parent p1 = new Child(); //부(선언부) 자(생성부)
		//문제 :도대제 child c는 Parent클래스의 메소드와 오버라이딩 관계에 있다는 것을
		//어떻게 알게 되는 걸까요?
		//자녀의 생성자가 호출되기 전에 부모의 생성자가 호출되기 때문이다.
		//자녀클래스를 인스턴ㄴ스화 하더라도 먼저 부모클래스의 디폴트 생성자를 먼저 호출합니다.
		//이 과정을 통해서 부모의 메소드의 정보를 알게 됩니다.
		Child c = new Child();   //자(선언부) 자(생성부)
		
		//(1).p로 누릴수 있는 것들을 코드로 작성해 보시오.
		p.book = "말의 힘"; //book변수를 private에서 public으로 변경후 사용
		p.bookRead(); /* 부모 클래스의 변수는 private이므로 사용 불가능 public인 함수만 사용가능*/
		System.out.println(p.book);
		p.bookRead(p.book, "자바프로그래밍 입문");
		
		//(2).p1으로 누릴수 있는 것들을 작성해 보시오.
		/*********
		 부모타입으로 선언하였으므로 자식 클래스에서 사용하고 있는 
		(즉, 부모 클래스안에는 없는 기능)은 자식 클래스로 생성하였어도 
		사용이 불가능 그러나 부모클래스에서 가진 함수를 자식클래스에서 
		재정의한 함수나 변수를 사용하고 싶을때 사용.
		**********/
		/*********
		부모 클래스를 재정의해서 가지고 있는 Child 클래스의 bookRead함수의 내용을 불러옴. 
		왜냐하면 p1은 부모타입이지만 생성하기를 자식 클래스를 생성하였기 때문이다. 
		자식클래스는 부모클래스보다 더욱 확장되었으므로 부모클래스타입으로 선언하고 자식클래스를 생성해서 사용가능하다.
		*********/
		p1.bookRead();
		
		//(3).c로 누릴수 있는 것들을 메소드들을 호출해 보시오.
		//Child에 선언되지 않은 변수이지만 상속관계에 있으므로 누릴 수 있다.
		c.book = "오라클프로그래밍";
		/*
		 * 동일한 메소드가 부모와 자식 모두에게 있을 경우 선언한 타입에서 제공하는 메소드가 호출된다. 
		 * 이 때 부모가 가진 bookRead메소드는 호출 할 수가 없다. 
		 * 왜냐하면 자녀타입으로 선언하였으므로 자식클래스에 선언한 메소드가 호출된다.
		 */
		c.bookRead();	//자식클래스에서 부모클래스함수를 재정의한 함수를 사용
		c.car = "tivoil"; //자식 클래스 안에 car변수를 사용
		c.carDriver();	//자식클래스안에서 정의한 함수를 사용
		
		//문제 : 만일 p1으로 동일한 메소드를 호출 한다면 어떤 메소드가 호출될까요?
		//1) 부모클래스의 메소드가 호출된다.
		
		//2) 자식클래스의 메소드가 호출된다.
		// - 선언부에는  부모타입으로 선언되고 생성부에서는 자식타입으로 생성되었으므로 부모타입의 메소드가 자식타입에서 
		// 재정의된 자식클래스의 함수로 호츨될것이다
	}
}
